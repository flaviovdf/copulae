# -*- coding: utf8 -*-
'''
This module is used to generate inputs for copula
neural networks
'''


from copulae.typing import Sequence
from copulae.typing import Tensor
from copulae.typing import Tuple

from copulae.sm.ecdf import ECDF

import jax
import jax.numpy as jnp


@jax.jit
def __interp1d_cond(
    dim1_key, dim2_key, dim1_vals, dim2_vals, C
):
    k1b = jnp.searchsorted(dim1_vals, dim1_key)
    k2b = jnp.searchsorted(dim2_vals, dim2_key)

    n = 0
    s = 0
    for pm1 in [0, 1]:
        for pm2 in [0, 1]:
            k1 = k1b + pm1
            k2 = k2b + pm2
            if k1 < C.shape[0] and k2 < C.shape[1]:
                s += C[k1, k2]
                n = n + 1
    return s / n


@jax.jit
def __populate_conditionals(
    U_bs, C_bs, C_uv, C_vu, us, vs
):
    for batch_i in range(U_bs.shape[0]):
        for k in range(U_bs.shape[2]):
            u = U_bs[batch_i, 0, k]
            v = U_bs[batch_i, 1, k]

            c_uv = __interp1d_cond(u, v, us, vs, C_uv)
            c_vu = __interp1d_cond(v, u, vs, us, C_vu)

            C_bs.at[batch_i, 0, k].set(c_uv)
            C_bs.at[batch_i, 1, k].set(c_vu)
    return C_bs


def __create_conditionals(ecdfs, D, dim1, dim2):
    ys = ecdfs[dim1][1]
    C = []
    cond = []
    for x, y_cond in zip(*ecdfs[dim2]):
        data = D[dim1, D[dim2] <= x]
        if data.shape[0] >= 1:
            ecdf_conditinal = ECDF(data, side='right')
            ss = jnp.searchsorted(ecdf_conditinal.y, ys)
            prob = ecdf_conditinal.y[ss]
        else:
            prob = jnp.zeros(len(ys), dtype=jnp.float32)
        C.append(prob)
        cond.append(y_cond)
    C = jnp.array(C, dtype=jnp.float32)
    cond = jnp.array(cond, dtype=jnp.float32)

    return C, cond


def __init_output(n_batches, n_features, batch_size):
    # U is used for the copula training
    # M are the marginal CDFs
    # C are conditional CDFs
    # X are the dataset values related to M
    # Y is the expected copula output
    U_bs = jnp.zeros(
        shape=(n_batches, n_features, batch_size),
        dtype=jnp.float32
    )
    M_bs = jnp.zeros(
        shape=(n_batches, n_features, batch_size),
        dtype=jnp.float32
    )
    C_bs = jnp.zeros(
        shape=(n_batches, n_features, batch_size),
        dtype=jnp.float32
    )
    X_bs = jnp.zeros(
        shape=(n_batches, n_features, batch_size),
        dtype=jnp.float32
    )
    Y_bs = jnp.zeros(
        shape=(n_batches, batch_size, 1),
        dtype=jnp.float32
    )
    return U_bs, M_bs, C_bs, X_bs, Y_bs


def __populate(
    key: jax.random.PRNGKey,
    D: Tensor,
    bootstrap: bool,
    ecdfs: Sequence[Tuple[Tensor, Tensor]],
    min_val: int,
    max_val: int,
    n_batches: int,
    batch_size: int
) -> Tuple[Tensor, Tensor, Tensor, Tensor]:

    n_features = D.shape[0]
    U_bs, M_bs, C_bs, X_bs, Y_bs = \
        __init_output(n_batches, n_features, batch_size)

    keys = jax.random.split(key, n_batches + 1)
    for batch_i in range(n_batches):
        if bootstrap:
            Ub = jax.random.uniform(
                keys[batch_i],
                shape=(n_features, batch_size),
                minval=min_val, maxval=max_val
            )
        else:
            Ub = jnp.zeros(
                shape=(n_features, batch_size),
                dtype=jnp.float32
            )
            for j, xy in enumerate(ecdfs):
                Ub.at[j].set(xy[1])

        mask = True
        for j, xy in enumerate(ecdfs):
            pos = jnp.searchsorted(
                xy[1], Ub[j]
            )

            vals_m = xy[1][pos]
            M_bs = M_bs.at[batch_i, j, :].set(vals_m)

            vals_x = xy[0][pos]
            X_bs = X_bs.at[batch_i, j, :].set(vals_x)

            lt = jnp.tile(
                D[j], batch_size
            ).reshape(
                D.shape[1],
                batch_size
            ) <= vals_x
            mask = mask & lt

        Yb = mask.mean(axis=0)
        Yb = Yb.reshape(batch_size, 1)

        U_bs = U_bs.at[batch_i].set(Ub)
        Y_bs = Y_bs.at[batch_i].set(Yb)

    R_bs = jax.random.uniform(
        keys[-1], minval=0, maxval=1.0 - U_bs
    )

    C_uv, vs = __create_conditionals(ecdfs, D, 0, 1)
    C_vu, us = __create_conditionals(ecdfs, D, 1, 0)

    C_bs = __populate_conditionals(
        U_bs, C_bs, C_uv, C_vu, us, vs
    )

    return U_bs, M_bs, C_bs, R_bs, X_bs, Y_bs


def generate_copula_net_input(
    key: jax.random.PRNGKey,
    D: Tensor,
    bootstrap: bool = True,
    min_val: int = 0,
    max_val: int = 1,
    n_batches: int = 128,
    batch_size: int = 64
) -> Tuple[Tensor, Tensor, Tensor, Tensor]:
    '''
    Creates the input tensors needed to train neural
    copulas. If `bootstrap=True` then random inputs are
    generated by empirically sampling from the CDF of the
    data. If `bootstrap=False`, then a single batch is
    returned.

    See the notes below for differences when
    bootstrapping and when not bootstrapping

    **Bootstrapping (bootstrap=True)**

    The returned tensors will be organized in batches
    (a total of `n_batches`), each batch containing
    `batch_size` elements.

    Batches are created using a bootstrap sampling
    procedure which generates samples based on the
    empirical cumulative distribution function (ecdf).

    The steps to produce the batches are as follows:
    1. For each dimension in the dataset `D`:
        a. Generate `batch_size` random numbers uniformly
           in [0, 1].
        b. For each of the numbers above, sample
           `batch_size` data points for that by
           sampling from the ecdf of the dimension.
        c. Store the uniform value from (a) in U; the
           data points in X; the ecdf of X in M
           (for marginal);
    2. and, finally store the joint ecdf for every
       dimension in Y.

    Steps (1) and (2) generate a single batch.

    **No Bootstrap (bootstrap=False)**

    A single batch is returned with the size of the
    dataset. The arguments returned are the same as when
    bootstrapping.

    The arguments `min_val`, `max_val`, `n_batches` and
    `batch_size` are ignored when not bootstrapping.

    Arguments
    ---------
    key: jax.random.PRNGKey
        The key used for random number generation, must be
        discarded afterwards.
    D: Tensor
        Our dataset of (`n_dimensions`, `n_samples`)
    min_val: int (defaults to 0)
    max_val: int (defaults to 1)
        Min and max values are used to generate the uniform
        random values used as input to the copula. By
        definition a copula receives only values in [0, 1]
        as input. However, we may sample values out of this
        range in order to train corner cases.
    n_batches: int
        Number of batches to generate
    batch_size: int
        The size of each batch

    Returns
    -------
    Six tensors:

    U_bs: Tensor (n_batches, n_dimensions, batch_size)
        The tensor that serves as input to train neural
        copulas.
    M_bs: Tensor (n_batches, n_dimensions, batch_size)
        Marginal cumulative distribution functions (ecdf)
        for each dimension.
    X_bs: Tensor (n_batches, n_dimensions, batch_size)
        Data points associated with each marginal above.
    Y_bs: Tensor (n_batches, n_dimensions, batch_size)
        The output of the neural copula. A joint cumulative
        distribution estimate of the values in `X_bs`.
    '''

    if len(D.shape) != 2 or D.shape[0] != 2:
        raise ValueError('D must be of shape (2, n)')

    if not bootstrap:
        min_val = 0.0
        max_val = 1.0
        n_batches = 1.0
        batch_size = D.shape[1]

    ecdfs = []
    ecdf = ECDF(D[0], side='right')
    ecdfs.append((ecdf.x, ecdf.y))
    ecdf = ECDF(D[1], side='right')
    ecdfs.append((ecdf.x, ecdf.y))

    return __populate(
        key, D, bootstrap, ecdfs, min_val, max_val,
        n_batches, batch_size
    )
